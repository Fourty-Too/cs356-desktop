{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ModalContext = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _class, _temp;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _classnames = require('classnames');\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nvar _reactModal = require('react-modal');\n\nvar _reactModal2 = _interopRequireDefault(_reactModal);\n\nvar _createReactContext = require('create-react-context');\n\nvar _createReactContext2 = _interopRequireDefault(_createReactContext);\n\nvar _reactLifecyclesCompat = require('react-lifecycles-compat');\n\nvar _Form = require('./Form');\n\nvar _Form2 = _interopRequireDefault(_Form);\n\nvar _Button = require('./Button');\n\nvar _Button2 = _interopRequireDefault(_Button);\n\nvar _Close = require('./Close');\n\nvar _Close2 = _interopRequireDefault(_Close);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar ModalContext = exports.ModalContext = (0, _createReactContext2.default)(); // Make sure to add `.rrui__fixed-full-width` CSS class\n// to all full-width `position: fixed` elements.\n// Such elements must not be `width: 100%`\n// but rather `width: auto` or `left: 0; right: 0;`.\n\nvar Modal = (_temp = _class = function (_Component) {\n  _inherits(Modal, _Component);\n\n  function Modal(props) {\n    _classCallCheck(this, Modal);\n\n    var _this = _possibleConstructorReturn(this, (Modal.__proto__ || Object.getPrototypeOf(Modal)).call(this, props));\n\n    _this.storeContentInstance = function (ref) {\n      return _this.content = ref;\n    };\n\n    _this.registerForm = function () {\n      // Using a counter instead of a boolean here\n      // because a new form may be mounted before the old one is unmounted.\n      // (React reconciliation algorythm implementation details)\n      _this.setState(function (_ref) {\n        var form = _ref.form;\n        return {\n          form: form + 1\n        };\n      });\n    };\n\n    _this.unregisterForm = function () {\n      if (_this.unmounted) {\n        return;\n      } // Using a counter instead of a boolean here\n      // because a new form may be mounted before the old one is unmounted.\n      // (React reconciliation algorythm implementation details)\n\n\n      _this.setState(function (_ref2) {\n        var form = _ref2.form;\n        return {\n          form: form - 1\n        };\n      });\n    };\n\n    _this.on_request_close = function (event) {\n      var closeLabel = _this.props.closeLabel;\n      var form = _this.state.form; // If the modal has an explicit \"Cancel\" button,\n      // then allow closing it by hitting \"Escape\" key,\n      // but don't close it on a click outside.\n      // (because a user wouldn't want to loose form data due to a misclick)\n\n      if (closeLabel && form && event && event.type !== 'keydown') {\n        _this.indicate_cannot_close(); // Focus on `<ReactModal/>` element.\n\n\n        return _this.content.focus();\n      }\n\n      _this.closeIfNotBusy();\n    };\n\n    _this.closeIfNotBusy = function () {\n      var _this$props = _this.props,\n          wait = _this$props.wait,\n          busy = _this$props.busy,\n          close = _this$props.close,\n          closeTimeout = _this$props.closeTimeout; // For weird messed development mode cases\n\n      if (_this.unmounted) {\n        return;\n      } // Don't close the modal if it's busy\n\n\n      if (wait || busy) {\n        return _this.indicate_cannot_close();\n      } // Abruptly end \"couldn't close\" animation to make room for closing animation\n\n\n      _this.setState({\n        could_not_close_because_busy: false\n      }); // Close the modal\n\n\n      if (close) {\n        close();\n      }\n    };\n\n    _this.on_after_open = function () {\n      var afterOpen = _this.props.afterOpen;\n\n      _this.adjust_scrollbar_after_open();\n\n      if (afterOpen) {\n        afterOpen();\n      }\n    };\n\n    _this.on_after_close = function () {\n      var _this$props2 = _this.props,\n          afterClose = _this$props2.afterClose,\n          reset = _this$props2.reset;\n\n      if (reset) {\n        reset();\n      }\n\n      if (afterClose) {\n        afterClose();\n      }\n\n      _this.adjust_scrollbar_after_close();\n    };\n\n    _this.state = {\n      // Using a counter instead of a boolean here\n      // because a new form may be mounted before the old one is unmounted.\n      // (React reconciliation algorythm implementation details)\n      form: 0,\n      context: {\n        closeLabel: _this.props.closeLabel,\n        closeIfNotBusy: _this.closeIfNotBusy,\n        registerForm: _this.registerForm,\n        unregisterForm: _this.unregisterForm\n      }\n    };\n    return _this;\n  }\n\n  _createClass(Modal, [{\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _props = this.props,\n          unmount = _props.unmount,\n          isOpen = _props.isOpen; // If prevent `<Modal/>` contents\n      // from being unmounted upon close.\n\n      if (!unmount) {\n        // If has been opened.\n        if (!prevProps.isOpen && isOpen) {\n          this.on_after_open();\n        } // If has been closed.\n        else if (prevProps.isOpen && !isOpen) {\n            this.on_after_close();\n            this.reset_content_scroll();\n          }\n      }\n    } // A modal itself umounts only when the user leaves a page,\n    // so in a \"Single Page Application\", for example,\n    // if this was a regular popup and a user could still navigate\n    // away via a hyperlink then this code becomes neccessary.\n\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      var isOpen = this.props.isOpen;\n      this.unmounted = true; // If the modal is still open\n      // while a user navigates away\n      // then \"close\" it properly\n      // (restore the document scrollbars, etc).\n\n      if (isOpen) {\n        this.on_after_close();\n      }\n\n      clearTimeout(this.could_not_close_because_busy_animation_timeout);\n      this.could_not_close_because_busy_animation_timeout = undefined;\n    }\n  }, {\n    key: 'getAppElement',\n    value: function getAppElement() {\n      var _props2 = this.props,\n          appElement = _props2.appElement,\n          appElementId = _props2.appElementId;\n\n      if (appElementId && typeof window !== 'undefined') {\n        return document.getElementById(appElementId);\n      }\n\n      return appElement;\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props3 = this.props,\n          wait = _props3.wait,\n          busy = _props3.busy,\n          fullscreen = _props3.fullscreen,\n          isOpen = _props3.isOpen,\n          closeTimeout = _props3.closeTimeout,\n          ariaLabel = _props3.ariaLabel,\n          contentLabel = _props3.contentLabel,\n          title = _props3.title,\n          closeLabel = _props3.closeLabel,\n          ariaHideApp = _props3.ariaHideApp,\n          closeButtonIcon = _props3.closeButtonIcon,\n          actions = _props3.actions,\n          unmount = _props3.unmount,\n          style = _props3.style,\n          className = _props3.className,\n          overlayClassName = _props3.overlayClassName,\n          children = _props3.children;\n      var _state = this.state,\n          could_not_close_because_busy = _state.could_not_close_because_busy,\n          form = _state.form; // `aria-modal` was added in WAI-ARIA 1.1 and is not supported yet.\n      // https://www.levelaccess.com/differences-aria-1-0-1-1-deprecations-additions/\n\n      return _react2.default.createElement(_reactModal2.default, {\n        isOpen: unmount ? isOpen : true,\n        onAfterOpen: unmount ? this.on_after_open : undefined,\n        onRequestClose: this.on_request_close,\n        closeTimeoutMS: closeTimeout,\n        contentLabel: this.props['aria-label'] || ariaLabel || contentLabel,\n        ariaHideApp: this.getAppElement() || globalAppElement ? ariaHideApp : false,\n        appElement: this.getAppElement(),\n        style: react_modal_style,\n        overlayClassName: (0, _classnames2.default)('rrui__modal__overlay', {\n          'rrui__modal__overlay--busy': wait || busy,\n          'rrui__modal__overlay--fullscreen': fullscreen,\n          'rrui__modal__overlay--hidden': !unmount && !isOpen\n        }, overlayClassName),\n        className: (0, _classnames2.default)( // A `<Modal/>` gets focused when it gets open\n        // and this causes an outline around it.\n        // This outline doesn't relate that much to actual\n        // accessibilty so it can be muted safely.\n        'rrui__outline', 'rrui__modal__container', {\n          'rrui__modal__container--fullscreen': fullscreen\n        })\n      }, _react2.default.createElement('div', {\n        className: (0, _classnames2.default)('rrui__modal__vertical-margin', 'rrui__modal__vertical-margin--top', {\n          // CSS selector performance optimization\n          'rrui__modal__vertical-margin--fullscreen': fullscreen\n        }),\n        onClick: this.on_request_close\n      }), _react2.default.createElement(ModalContext.Provider, {\n        value: this.state.context\n      }, _react2.default.createElement(ModalContent, {\n        ref: this.storeContentInstance,\n        closeLabel: closeLabel,\n        closeButtonIcon: closeButtonIcon,\n        close: this.closeIfNotBusy,\n        style: style,\n        className: className,\n        fullscreen: fullscreen,\n        could_not_close_because_busy: could_not_close_because_busy,\n        containsForm: form > 0,\n        wait: wait || busy,\n        reset: this.on_after_close\n      }, children)), _react2.default.createElement('div', {\n        className: (0, _classnames2.default)('rrui__modal__vertical-margin', 'rrui__modal__vertical-margin--bottom', {\n          // CSS selector performance optimization\n          'rrui__modal__vertical-margin--fullscreen': fullscreen\n        }),\n        onClick: this.on_request_close\n      }));\n    }\n  }, {\n    key: 'indicate_cannot_close',\n    // Play \"cannot close\" animation on the modal\n    value: function indicate_cannot_close() {\n      var _this2 = this;\n\n      var could_not_close_because_busy_animation_duration = this.props.could_not_close_because_busy_animation_duration;\n      var could_not_close_because_busy = this.state.could_not_close_because_busy;\n\n      if (!could_not_close_because_busy) {\n        this.could_not_close_because_busy_animation_timeout = setTimeout(function () {\n          _this2.could_not_close_because_busy_animation_timeout = undefined;\n\n          _this2.setState({\n            could_not_close_because_busy: false\n          });\n        }, // Give it a bit of extra time to finish the CSS animation\n        could_not_close_because_busy_animation_duration * 1.1);\n        this.setState({\n          could_not_close_because_busy: true\n        });\n      }\n    }\n  }, {\n    key: 'reset_content_scroll',\n    // If the user scrolled on a previously shown react-modal,\n    // then reset that previously scrolled position.\n    value: function reset_content_scroll() {\n      document.querySelector('.ReactModal__Overlay').scrollTop = 0;\n    } // Hides the main (body) scrollbar upon showing a modal\n    // and also adjusts the width of all \"full-width\" elements\n    // so that they don't expand no that the scrollbar is absent.\n    //\n    // This doesn't account for window resizes\n    // but since my body is always `overflow: visible` (a good practice)\n    // there's no difference and it should work in any scenario.\n    //\n\n  }, {\n    key: 'adjust_scrollbar_after_open',\n    value: function adjust_scrollbar_after_open() {\n      // A dummy `<div/>` to measure\n      // the difference in width\n      // needed for the \"full-width\" elements\n      // after the main (body) scrollbar is deliberately hidden.\n      var div = document.createElement('div');\n      div.style.position = 'fixed';\n      div.style.left = 0;\n      div.style.right = 0;\n      document.body.appendChild(div); // Calculate the width of the dummy `<div/>`\n      // before the main (body) scrollbar is deliberately hidden.\n\n      var width_before = div.clientWidth; // Hide the main (body) scrollbar\n      // so that when a user scrolls in an open modal\n      // this `scroll` event doesn't go through\n      // and scroll the main page.\n\n      document.body.style.overflow = 'hidden'; // All \"full-width\" elements will need their\n      // width to be adjusted by this amount\n      // because of the now-hidden main (body) scrollbar\n      // Calculate the width of the dummy `<div/>`\n      // after the main (body) scrollbar is deliberately hidden.\n\n      var width_adjustment = div.clientWidth - width_before;\n      document.body.removeChild(div); // \"full-width\" elements include `document.body`\n      // and all `position: fixed` elements\n      // which should be marked with this special CSS class.\n      //\n      // Make sure to add `.rrui__fixed-full-width` CSS class\n      // to all full-width `position: fixed` elements.\n      // Such elements must not be `width: 100%`\n      // but rather `width: auto` or `left: 0; right: 0;`.\n      //\n      // Adjusts the width of all \"full-width\" elements\n      // so that they don't expand by the width of the (now absent) scrollbar\n      //\n\n      for (var _iterator = get_full_width_elements(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref3;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref3 = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref3 = _i.value;\n        }\n\n        var element = _ref3;\n        element.style.marginRight = width_adjustment + 'px';\n      }\n\n      this.reset_content_scroll();\n    }\n  }, {\n    key: 'adjust_scrollbar_after_close',\n    // Restores original `document` scrollbar.\n    value: function adjust_scrollbar_after_close() {\n      var _props4 = this.props,\n          bodyOverflowX = _props4.bodyOverflowX,\n          bodyOverflowY = _props4.bodyOverflowY; // All \"full-width\" elements will need their\n      // width to be restored back to the original value\n      // now that the main (body) scrollbar is being restored.\n      // \"full-width\" elements include `document.body`\n      // and all `position: fixed` elements\n      // which should be marked with this special CSS class.\n      //\n      // Make sure to add `.rrui__fixed-full-width` CSS class\n      // to all full-width `position: fixed` elements.\n      // Such elements must not be `width: 100%`\n      // but rather `width: auto` or `left: 0; right: 0;`.\n      //\n      // Adjusts the width of all \"full-width\" elements back to their original value\n      // now that the main (body) scrollbar is being restored.\n      //\n\n      for (var _iterator2 = get_full_width_elements(), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref4;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref4 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref4 = _i2.value;\n        }\n\n        var element = _ref4;\n        element.style.marginRight = 0;\n      } // Restore the main (body) scrollbar.\n\n\n      document.body.style.overflowX = bodyOverflowX;\n      document.body.style.overflowY = bodyOverflowY;\n    } // Restores original `document` scrollbar\n    // and resets the modal content (e.g. a form)\n\n  }], [{\n    key: 'getDerivedStateFromProps',\n    value: function getDerivedStateFromProps(props, state) {\n      if (props.closeLabel !== state.context.closeLabel) {\n        return _extends({}, state, {\n          context: _extends({}, state.context, {\n            closeLabel: props.closeLabel\n          })\n        });\n      }\n\n      return null;\n    }\n  }]);\n\n  return Modal;\n}(_react.Component), _class.propTypes = {\n  // If `true` then the modal is shown\n  isOpen: _propTypes2.default.bool.isRequired,\n  // Closes the modal (must set the `isOpen` flag to `false`)\n  close: _propTypes2.default.func.isRequired,\n  // A time required for CSS hiding animation to complete\n  // (150 milliseconds by default)\n  closeTimeout: _propTypes2.default.number.isRequired,\n  // Is called after the modal is shown\n  afterOpen: _propTypes2.default.func,\n  // Is called after the modal is closed\n  afterClose: _propTypes2.default.func,\n  // Enters fullscreen mode\n  fullscreen: _propTypes2.default.bool,\n  // Modal content\n  children: _propTypes2.default.node,\n  // If `wait` is `true` then the modal\n  // won't close on click-out or Escape\n  // and will show spinner on the overlay.\n  wait: _propTypes2.default.bool,\n  // (deprecated)\n  // (use `wait` instead)\n  // If `busy` is `true` then the modal\n  // won't close on click-out or Escape\n  // and will show spinner on the overlay.\n  busy: _propTypes2.default.bool,\n  // Resets the modal on close\n  // (e.g. could reset edited form fields)\n  reset: _propTypes2.default.func,\n  // \"Cancel\" button label.\n  // If set, the modal will have a \"Cancel\" button.\n  // (only if `<Form.Actions/>` is found in content)\n  closeLabel: _propTypes2.default.string,\n  // The default `overflow-x` of the <body/>.\n  // Is `auto` by default.\n  bodyOverflowX: _propTypes2.default.string.isRequired,\n  // The default `overflow-x` of the <body/>.\n  // Is `scroll` by default\n  // (which is better than `auto`\n  //  because the document width won't be jumpy\n  //  while navigating the website â€”\n  //  it will be consistent across all pages)\n  bodyOverflowY: _propTypes2.default.string.isRequired,\n  // Deprecated, use `aria-label` instead.\n  ariaLabel: _propTypes2.default.string,\n  // Deprecated, use `aria-label` instead.\n  contentLabel: _propTypes2.default.string,\n  // `aria-hidden` will be set to true on the `appElement`.\n  appElement: _propTypes2.default.any,\n  appElementId: _propTypes2.default.string,\n  // Whether to set `aria-hidden` on the `appElement`.\n  // Is `true` inside `react-modal` by default.\n  ariaHideApp: _propTypes2.default.bool,\n  // An optional close button icon (like a cross).\n  // Set to `true` to show the default \"cross\" icon.\n  closeButtonIcon: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.oneOf([true])]),\n  // If set to `false` will prevent modal contents\n  // from being unmounted when the modal is closed.\n  unmount: _propTypes2.default.bool.isRequired,\n  // Internal property\n  could_not_close_because_busy_animation_duration: _propTypes2.default.number.isRequired,\n  // CSS class for overlay (e.g. for fullscreen modal background color)\n  overlayClassName: _propTypes2.default.string,\n  // CSS class\n  className: _propTypes2.default.string,\n  // CSS style object\n  style: _propTypes2.default.object\n}, _class.defaultProps = {\n  isOpen: false,\n  bodyOverflowX: 'auto',\n  // Prevents document width from jumping due to the\n  // vertical scrollbar appearance/disappearance\n  bodyOverflowY: 'scroll',\n  // when changing this also change\n  // your .ReactModal__Overlay and .ReactModal__Content\n  // css transition times accordingly\n  closeTimeout: 150,\n  // ms\n  // Modal contents are unmounted when the modal is closed by default\n  unmount: true,\n  // When changing this also change\n  // `.rrui__modal--could-not-close-because-busy`\n  // css transition time accordingly\n  could_not_close_because_busy_animation_duration: 600 // ms\n\n}, _temp);\n\nvar ModalContent = function (_Component2) {\n  _inherits(ModalContent, _Component2);\n\n  function ModalContent() {\n    var _ref5;\n\n    var _temp2, _this3, _ret;\n\n    _classCallCheck(this, ModalContent);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp2 = (_this3 = _possibleConstructorReturn(this, (_ref5 = ModalContent.__proto__ || Object.getPrototypeOf(ModalContent)).call.apply(_ref5, [this].concat(args))), _this3), _this3.storeNode = function (ref) {\n      return _this3.node = ref;\n    }, _temp2), _possibleConstructorReturn(_this3, _ret);\n  }\n\n  _createClass(ModalContent, [{\n    key: 'focus',\n    value: function focus() {\n      this.node.focus();\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      var reset = this.props.reset;\n\n      if (reset) {\n        reset();\n      }\n    }\n  }, {\n    key: 'transformChildren',\n    value: function transformChildren() {\n      var _this4 = this;\n\n      var _props5 = this.props,\n          closeLabel = _props5.closeLabel,\n          closeButtonIcon = _props5.closeButtonIcon,\n          close = _props5.close,\n          containsForm = _props5.containsForm,\n          children = _props5.children;\n      var closeButtonAdded = false;\n      return _react2.default.Children.map(children, function (element) {\n        if (closeButtonIcon && !closeButtonAdded) {\n          if (element.type === ModalTitleType || element.type === ModalContentType) {\n            closeButtonAdded = true;\n            return _react2.default.cloneElement(element, {\n              closeButton: _this4.render_close_button()\n            });\n          }\n        }\n\n        if (!closeButtonIcon && closeLabel && !containsForm && element.type === Modal.Actions) {\n          return _react2.default.cloneElement(element, {\n            closeButton: _react2.default.createElement(_Button2.default, {\n              className: (0, _classnames2.default)('rrui__modal__close', 'rrui__modal__close--bottom'),\n              action: close\n            }, closeLabel)\n          });\n        }\n\n        return element;\n      });\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props6 = this.props,\n          fullscreen = _props6.fullscreen,\n          className = _props6.className,\n          style = _props6.style,\n          could_not_close_because_busy = _props6.could_not_close_because_busy;\n      return _react2.default.createElement('div', {\n        ref: this.storeNode,\n        className: (0, _classnames2.default)('rrui__modal__contents', {\n          // CSS selector performance optimization\n          'rrui__modal__contents--fullscreen': fullscreen,\n          // Strictly speaking it's not `.rrui__modal` but this CSS class name will do\n          'rrui__modal--could-not-close-because-busy': could_not_close_because_busy\n        }, className),\n        style: style\n      }, this.transformChildren());\n    }\n  }, {\n    key: 'render_close_button',\n    value: function render_close_button() {\n      var _props7 = this.props,\n          closeLabel = _props7.closeLabel,\n          closeButtonIcon = _props7.closeButtonIcon,\n          close = _props7.close,\n          wait = _props7.wait;\n      var CloseButtonIcon = closeButtonIcon === true ? _Close.CloseIcon : closeButtonIcon;\n\n      if (!CloseButtonIcon) {\n        return null;\n      }\n\n      return _react2.default.createElement(_Close2.default, {\n        onClick: close,\n        closeLabel: closeLabel,\n        className: (0, _classnames2.default)('rrui__modal__close', 'rrui__modal__close--top', {\n          'rrui__modal__close--busy': wait\n        })\n      }, _react2.default.createElement(CloseButtonIcon, null));\n    }\n  }]);\n\n  return ModalContent;\n}(_react.Component);\n\nvar react_modal_style = {\n  overlay: {\n    position: 'fixed',\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n    // Will show a scrollbar in case of modal content overflowing viewport height\n    overflow: 'auto' // \"full-width\" elements include `document.body`\n    // and all `position: fixed` elements\n    // which should be marked with this special CSS class.\n    //\n    // Make sure to add `.rrui__fixed-full-width` CSS class\n    // to all full-width `position: fixed` elements.\n    // Such elements must not be `width: 100%`\n    // but rather `width: auto` or `left: 0; right: 0;`.\n    //\n\n  }\n};\n\nfunction get_full_width_elements() {\n  // `Array.from` requires ES6 polyfill.\n  // const full_width_elements = Array.from(document.querySelectorAll('.rrui__fixed-full-width'))\n  var full_width_elements = [].slice.call(document.querySelectorAll('.rrui__fixed-full-width'));\n  full_width_elements.push(document.body);\n  return full_width_elements;\n}\n\nvar Title = function Title(_ref6) {\n  var closeButton = _ref6.closeButton,\n      className = _ref6.className,\n      children = _ref6.children,\n      rest = _objectWithoutProperties(_ref6, ['closeButton', 'className', 'children']);\n\n  return _react2.default.createElement('h2', _extends({\n    className: (0, _classnames2.default)('rrui__modal__title', className, {\n      'rrui__modal__title--close-button': closeButton\n    })\n  }, rest), closeButton && _react2.default.createElement('span', {\n    className: 'rrui__modal__title-itself'\n  }, children), !closeButton && children, closeButton);\n};\n\nvar Content = function Content(_ref7) {\n  var closeButton = _ref7.closeButton,\n      className = _ref7.className,\n      children = _ref7.children,\n      rest = _objectWithoutProperties(_ref7, ['closeButton', 'className', 'children']);\n\n  return _react2.default.createElement('div', _extends({\n    className: (0, _classnames2.default)('rrui__modal__content', className, {\n      'rrui__modal__content--close-button': closeButton\n    })\n  }, rest), closeButton && _react2.default.createElement('div', {\n    className: 'rrui__modal__content-itself'\n  }, children), !closeButton && children, closeButton);\n};\n\nvar Actions = function Actions(_ref8) {\n  var closeButton = _ref8.closeButton,\n      children = _ref8.children;\n  return _react2.default.createElement('div', {\n    className: 'rrui__modal__actions'\n  }, closeButton, children);\n}; // Workaround for `react-hot-loader`.\n// https://github.com/gaearon/react-hot-loader#checking-element-types\n\n\nvar ModalTitleType = _react2.default.createElement(Title, null).type;\n\nvar ModalContentType = _react2.default.createElement(Content, null).type;\n\nModal = (0, _reactLifecyclesCompat.polyfill)(Modal);\nModal.Title = Title;\nModal.Content = Content;\nModal.Actions = Actions;\nvar globalAppElement = void 0;\n\nModal.setAppElement = function (element) {\n  globalAppElement = element;\n\n  _reactModal2.default.setAppElement(element);\n};\n\nexports.default = Modal;","map":null,"metadata":{},"sourceType":"script"}