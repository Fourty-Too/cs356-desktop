{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _class, _class2, _temp2;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _reactLifecyclesCompat = require('react-lifecycles-compat');\n\nvar _classnames = require('classnames');\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nvar _ExpandableList = require('./ExpandableList');\n\nvar _ExpandableList2 = _interopRequireDefault(_ExpandableList);\n\nvar _List = require('./List');\n\nvar _List2 = _interopRequireDefault(_List);\n\nvar _TextInputLabel = require('./TextInputLabel');\n\nvar _TextInputLabel2 = _interopRequireDefault(_TextInputLabel);\n\nvar _TextInputInput = require('./TextInputInput');\n\nvar _TextInputInput2 = _interopRequireDefault(_TextInputInput);\n\nvar _Ellipsis = require('./Ellipsis');\n\nvar _Ellipsis2 = _interopRequireDefault(_Ellipsis);\n\nvar _WithError = require('./WithError');\n\nvar _WithError2 = _interopRequireDefault(_WithError);\n\nvar _reduxForm = require('./utility/redux-form');\n\nvar _dom = require('./utility/dom');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // `PureComponent` is only available in React >= 15.3.0.\n\n\nvar PureComponent = _react2.default.PureComponent || _react2.default.Component;\nvar empty_value_option_value = '';\n\nvar Autocomplete = (0, _reactLifecyclesCompat.polyfill)(_class = (_temp2 = _class2 = function (_PureComponent) {\n  _inherits(Autocomplete, _PureComponent);\n\n  function Autocomplete() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Autocomplete);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Autocomplete.__proto__ || Object.getPrototypeOf(Autocomplete)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      // The sequential counter for `async getOptions()`:\n      // the `options` with the highest counter are shown\n      // to prevent \"race condition\" inconsistency.\n      // Older options can only be overwritten with newer ones.\n      optionsCounter: 0,\n      matchesCounter: 0,\n      inputValue: '',\n      options: [],\n      // `prevProps` for `getDerivedStateFromProps()`.\n      props: {} // Latest `async getOptions()` invocation timestamp (for throttling).\n\n    }, _this.latestFetchOptionsCallTimestamp = 0, _this.counter = new Counter(), _this.onPreloadStateChange = function (isPreloading) {\n      return _this.setState({\n        isFetchingOptions: isPreloading\n      });\n    }, _this.focus = function () {\n      return _this.input.focus();\n    }, _this.onCollapse = function (_ref2) {\n      var collapsedDueToItemBeingSelected = _ref2.collapsedDueToItemBeingSelected,\n          focusOut = _ref2.focusOut;\n      var _this$state = _this.state,\n          options = _this$state.options,\n          selectedOption = _this$state.selectedOption;\n\n      _this.setState({\n        isExpanded: false,\n        matches: undefined\n      });\n\n      if (!collapsedDueToItemBeingSelected && !_this.collapsedDueToEmptyValueOnEnter) {\n        _this.setState({\n          inputValue: selectedOption ? selectedOption.label : ''\n        });\n      }\n\n      if (!focusOut) {\n        _this.dontExpandOnFocus = true;\n\n        _this.focus();\n\n        _this.dontExpandOnFocus = false;\n      }\n    }, _this.onExpand = function () {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _this.setState({\n        isExpanded: true\n      });\n    }, _this.onFocusItem = function (i, options) {\n      if (options.interaction) {\n        _this.setState({\n          focusedOptionIndex: i\n        });\n      } else {\n        _this.setState({\n          focusedOptionIndex: undefined\n        });\n      }\n    }, _this.expand = function () {\n      // Reset the \"matches\" state before expanding.\n      _this.setState({\n        matches: true\n      }, _this._expand);\n    }, _this._expand = function (parameters) {\n      return _this.list.expand(parameters);\n    }, _this.collapse = function () {\n      return _this.list.collapse();\n    }, _this.toggle = function () {\n      return _this.list.toggle();\n    }, _this.storeListRef = function (ref) {\n      return _this.list = ref;\n    }, _this.storeInput = function (node) {\n      return _this.input = node;\n    }, _this.storeInputComponentNode = function (node) {\n      return _this.inputComponentNode = node;\n    }, _this.getInputNode = function () {\n      return _this.input;\n    }, _this.expandOnFocus = function () {\n      if (_this.dontExpandOnFocus) {\n        return;\n      }\n\n      var isExpanded = _this.state.isExpanded;\n\n      if (!isExpanded) {\n        _this.setState({\n          matches: true\n        }, _this.expand);\n      }\n    }, _this.onInputValueChange = function (value) {\n      var isExpanded = _this.state.isExpanded; // Rewrite this somehow.\n      //\n      // When `highlightFirstOption` is `true`\n      // this is a special case when the first option is not highlighted.\n\n      if (!value && isExpanded) {\n        _this.list.focusItem(undefined);\n      }\n\n      _this.setState({\n        inputValue: value\n      }, function () {\n        _this._expand({\n          refresh: true\n        });\n      });\n    }, _this.onKeyDown = function (event) {\n      var _this$props = _this.props,\n          disabled = _this$props.disabled,\n          value = _this$props.value,\n          required = _this$props.required,\n          highlightFirstOption = _this$props.highlightFirstOption;\n      var _this$state2 = _this.state,\n          options = _this$state2.options,\n          isExpanded = _this$state2.isExpanded,\n          inputValue = _this$state2.inputValue,\n          focusedOptionIndex = _this$state2.focusedOptionIndex;\n\n      if (disabled) {\n        return;\n      }\n\n      if (event.defaultPrevented) {\n        return;\n      }\n\n      if (!isExpanded) {\n        if ((0, _dom.submitFormOnCtrlEnter)(event, _this.input)) {\n          return;\n        }\n      }\n\n      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n        return;\n      }\n\n      switch (event.keyCode) {\n        // \"Up\" arrow.\n        // Select the previous item (if present).\n        case 38:\n          if (isExpanded) {\n            // If no item was selected then do nothing.\n            if (_this.list.getFocusedItemIndex() === undefined) {} // Don't select any list item.\n            // If the first item was selected.\n            else if (_this.list.getFocusedItemIndex() === 0) {\n                // then unselect it.\n                if (!highlightFirstOption) {\n                  _this.list.clearFocus();\n                }\n\n                event.preventDefault();\n              } else {\n                _this.list.onKeyDown(event);\n              }\n          }\n\n          return;\n        // \"Down\" arrow.\n        // Select the next item (if present).\n\n        case 40:\n          if (isExpanded) {\n            // An edge case for `highlightFirstOption`\n            // when there's only one option available\n            // so pressing \"Down\" arrow key won't result in\n            // `onFocusItem` call which won't set `focusedOptionIndex`\n            // in order for screen reader to announce it.\n            if (highlightFirstOption && focusedOptionIndex === undefined && options.length === 1) {\n              _this.setState({\n                focusedOptionIndex: 0\n              });\n            } else {\n              // Navigate the list (if it was already expanded).\n              _this.list.onKeyDown(event);\n            }\n          } else {\n            // Expand the list if it's collapsed.\n            event.preventDefault();\n\n            _this.expand();\n          }\n\n          return;\n        // \"Left\" arrow.\n\n        case 37: // \"Right\" arrow.\n\n        case 39:\n          // Exit \"focus options\" mode.\n          if (isExpanded) {\n            _this.list.clearFocus();\n\n            if (highlightFirstOption) {\n              _this.list.focusItem(0);\n            }\n          }\n\n          return;\n        // \"Escape\".\n        // Collapse.\n\n        case 27:\n          event.preventDefault();\n\n          _this.collapse();\n\n          return;\n        // \"Enter\".\n\n        case 13:\n          if (!inputValue) {\n            // If no option is selected and the input value is empty\n            // then set `value` to `undefined`.\n            if (isExpanded && _this.list.getFocusedItemIndex() === undefined) {\n              // Don't submit the form.\n              event.preventDefault();\n\n              _this.setValue(undefined);\n\n              _this.collapsedDueToEmptyValueOnEnter = true;\n\n              _this.collapse();\n\n              _this.collapsedDueToEmptyValueOnEnter = undefined;\n              return;\n            }\n\n            if (!isExpanded) {\n              // If `value` is `undefined` and input value is empty\n              // then by default it submits the form.\n              if (isEmptyValue(value)) {\n                // If the value is required then expand the options list.\n                if (required) {\n                  // Don't submit the form\n                  event.preventDefault();\n\n                  _this.expand();\n                }\n\n                return;\n              } // If the input value has been cleared\n              // and the options list is collapsed\n              // (for example, via Escape key)\n              // then set `value` to `undefined`\n              // and don't submit the form.\n\n\n              event.preventDefault();\n\n              _this.setValue(undefined);\n\n              return;\n            }\n          } // Select the currently focused item (if expanded).\n\n\n          if (isExpanded) {\n            // Don't submit the form.\n            event.preventDefault(); // Choose the focused option.\n\n            _this.list.chooseFocusedItem();\n          }\n\n          return;\n      }\n    }, _this.fetchDefaultOptions = function () {\n      var _this$props2 = _this.props,\n          getOptions = _this$props2.getOptions,\n          filterOptions = _this$props2.filterOptions;\n      return Promise.resolve().then(function () {\n        return getOptions ? getOptions('') : filterOptions(_this.props.options, '');\n      }).then(function (options) {\n        return new Promise(function (resolve) {\n          return _this.setState({\n            options: options\n          }, resolve);\n        });\n      });\n    }, _this.refreshOptions = function () {\n      var _this$props3 = _this.props,\n          getOptions = _this$props3.getOptions,\n          filterOptions = _this$props3.filterOptions;\n      var inputValue = _this.state.inputValue;\n      return new Promise(function (resolve) {\n        // If throttled then schedule a future invocation.\n        if (getOptions) {\n          if (_this.throttleFetchOptionsCall(resolve)) {\n            return;\n          }\n\n          _this.latestFetchOptionsCallTimestamp = Date.now();\n\n          var counter = _this.counter.getNextCounter();\n\n          return _this.setState({\n            isFetchingOptions: true,\n            fetchingOptionsCounter: counter\n          }, function () {\n            getOptions(inputValue).then(function (options) {\n              _this.handleNewOptions(options, counter, resolve);\n            });\n          });\n        }\n\n        var newOptions = filterOptions(_this.props.options, inputValue);\n\n        _this.handleNewOptions(newOptions, null, resolve);\n      });\n    }, _this.handleNewOptions = function (options, counter, resolve) {\n      Promise.resolve(options).then(function (options) {\n        // Autocomplete should always display some options.\n        if (options.length === 0 && _this.state.options.length === 0) {\n          return _this.fetchDefaultOptions().then(function () {\n            return options;\n          });\n        }\n\n        return options;\n      }).then(function (options) {\n        _this.receiveNewOptions(options, counter, resolve);\n      }).catch(function (error) {\n        console.error(error);\n\n        _this.receiveNewOptions([], counter, resolve);\n      });\n    }, _this.setValue = function (newValue) {\n      var _this$props4 = _this.props,\n          value = _this$props4.value,\n          onChange = _this$props4.onChange;\n      var options = _this.state.options;\n      var selectedOption = options.filter(function (_) {\n        return _.value === newValue;\n      })[0];\n\n      _this.setState({\n        selectedOption: selectedOption,\n        inputValue: selectedOption ? selectedOption.label : ''\n      }); // Call `onChange` only if the `value` did change.\n\n\n      if (newValue !== value) {\n        onChange(newValue);\n      }\n    }, _this.onBlur = function (event) {\n      var _this$props5 = _this.props,\n          onBlur = _this$props5.onBlur,\n          value = _this$props5.value;\n\n      if (onBlur) {\n        (0, _reduxForm.onBlurForReduxForm)(onBlur, event, value);\n      }\n\n      _this.list && _this.list.onBlur(event);\n    }, _this.onClick = function (event) {\n      var disabled = _this.props.disabled;\n\n      if (!disabled) {\n        _this.expandOnFocus();\n      }\n    }, _this.onFocusOut = function (event) {\n      var _this$props6 = _this.props,\n          onBlur = _this$props6.onBlur,\n          value = _this$props6.value;\n      var inputValue = _this.state.inputValue; // `window.rruiCollapseOnFocusOut` can be used\n      // for debugging expandable contents.\n\n      if (window.rruiCollapseOnFocusOut !== false) {\n        _this.collapse();\n      }\n\n      if (!inputValue) {\n        value = undefined;\n\n        _this.setValue(value);\n      }\n\n      if (onBlur) {\n        (0, _reduxForm.onBlurForReduxForm)(onBlur, event, value);\n      }\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  } // Older options can only be overwritten with newer ones.\n  // (in case of `async getOptions()`).\n\n\n  _createClass(Autocomplete, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      var _props = this.props,\n          value = _props.value,\n          getOptions = _props.getOptions,\n          getOption = _props.getOption; // Generate unique ID.\n\n      var id = 'rrui-autocomplete';\n\n      while (document.getElementById(id + '__input')) {\n        id = 'rrui-autocomplete-' + generateRandomString();\n      }\n\n      this.input.id = id + '__input';\n      this.setState({\n        id: id\n      });\n\n      if (!isEmptyValue(value) && !getOption && getOptions) {\n        throw new Error(\"An initial `value` was passed to `<Autocomplete/>` which has `getOptions` but doesn't have `getOption` to get the label for that initial `value`.\");\n      }\n\n      if (!isEmptyValue(value) && getOption) {\n        this.setState({\n          isFetchingInitiallySelectedOption: true\n        });\n        getOption(value).then(function (option) {\n          _this2.setState({\n            selectedOption: option,\n            inputValue: option ? option.label : '',\n            isFetchingInitiallySelectedOption: false\n          });\n        }, function (error) {\n          console.error(error);\n\n          _this2.setState({\n            isFetchingInitiallySelectedOption: false\n          });\n        });\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      clearTimeout(this.nextFetchOptionsCallTimeout);\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props2 = this.props,\n          icon = _props2.icon,\n          compact = _props2.compact,\n          scroll = _props2.scroll,\n          scrollMaxItems = _props2.scrollMaxItems,\n          scrollIntoView = _props2.scrollIntoView,\n          alignment = _props2.alignment,\n          saveOnIcons = _props2.saveOnIcons,\n          highlightFirstOption = _props2.highlightFirstOption,\n          required = _props2.required,\n          label = _props2.label,\n          placeholder = _props2.placeholder,\n          value = _props2.value,\n          onChange = _props2.onChange,\n          indicateInvalid = _props2.indicateInvalid,\n          error = _props2.error,\n          closeButtonIcon = _props2.closeButtonIcon,\n          closeLabel = _props2.closeLabel,\n          style = _props2.style,\n          className = _props2.className;\n      var _state = this.state,\n          id = _state.id,\n          options = _state.options,\n          isFetchingOptions = _state.isFetchingOptions,\n          isFetchingInitiallySelectedOption = _state.isFetchingInitiallySelectedOption,\n          isExpanded = _state.isExpanded,\n          inputValue = _state.inputValue;\n      var containerStyle = {\n        textAlign: alignment // ARIA 1.1 (accessibility) docs:\n        // https://www.w3.org/TR/wai-aria-practices/examples/combobox/aria1.1pattern/listbox-combo.html\n        // (not yet supported)\n        //\n        // ARIA 1.0 (accessibility) docs:\n        // https://www.w3.org/TR/wai-aria-practices/examples/combobox/aria1.0pattern/combobox-autocomplete-list.html\n        // (is supported)\n        // value={options.length === 0 ? undefined : (inputValue.trim() === '' ? undefined : value)}\n\n      };\n      return _react2.default.createElement(_WithError2.default, {\n        id: id,\n        error: error,\n        indicateInvalid: indicateInvalid,\n        style: style ? _extends({}, containerStyle, style) : containerStyle,\n        className: (0, _classnames2.default)(className, 'rrui__autocomplete', {\n          'rrui__autocomplete--expanded': isExpanded,\n          'rrui__autocomplete--compact': compact || icon\n        })\n      }, _react2.default.createElement('div', {\n        ref: this.storeInputComponentNode,\n        className: 'rrui__input'\n      }, (isFetchingOptions || isFetchingInitiallySelectedOption) && _react2.default.createElement(_Ellipsis2.default, null), this.renderTextInput(), label && _react2.default.createElement(_TextInputLabel2.default, {\n        'aria-hidden': true,\n        inputId: id ? id + '__input' : undefined,\n        value: value,\n        required: required,\n        invalid: indicateInvalid && error\n      }, label), _react2.default.createElement(_ExpandableList2.default, {\n        ref: this.storeListRef,\n        id: id ? id + '__list' : undefined,\n        items: options,\n        value: options.length === 0 ? undefined : value,\n        highlightFirstItem: highlightFirstOption && inputValue.trim() !== '',\n        alignment: alignment,\n        scrollIntoView: scrollIntoView,\n        preload: this.refreshOptions,\n        onPreloadStateChange: this.onPreloadStateChange,\n        onFocusItem: this.onFocusItem,\n        scrollMaxItems: scroll === false ? 0 : scrollMaxItems,\n        shouldFocus: false,\n        onChange: this.setValue,\n        onCollapse: this.onCollapse,\n        onExpand: this.onExpand,\n        focusOnExpand: false,\n        highlightSelectedItem: false,\n        tabbable: false,\n        getTogglerNode: this.getInputNode,\n        onFocusOut: this.onFocusOut,\n        closeButtonIcon: closeButtonIcon,\n        closeLabel: closeLabel,\n        'aria-label': this.props['aria-label'] || label,\n        className: (0, _classnames2.default)('rrui__shadow', 'rrui__options-list', {\n          'rrui__options-list--left-aligned': alignment === 'left',\n          'rrui__options-list--right-aligned': alignment === 'right'\n        })\n      }, this.getOptionsForRendering().map(function (option, i) {\n        return _react2.default.createElement(_List2.default.Item, {\n          key: i,\n          id: id ? id + '__list-item-' + i : undefined,\n          value: option.value,\n          icon: saveOnIcons ? undefined : option.icon\n        }, option.content ? option.content(option) : option.label);\n      }))));\n    }\n  }, {\n    key: 'renderTextInput',\n    value: function renderTextInput() {\n      var _props3 = this.props,\n          value = _props3.value,\n          label = _props3.label,\n          placeholder = _props3.placeholder,\n          disabled = _props3.disabled,\n          required = _props3.required,\n          indicateInvalid = _props3.indicateInvalid,\n          error = _props3.error,\n          tabIndex = _props3.tabIndex,\n          inputClassName = _props3.inputClassName;\n      var _state2 = this.state,\n          id = _state2.id,\n          isExpanded = _state2.isExpanded,\n          inputValue = _state2.inputValue,\n          matches = _state2.matches,\n          isFetchingInitiallySelectedOption = _state2.isFetchingInitiallySelectedOption,\n          focusedOptionIndex = _state2.focusedOptionIndex; // To expand on click/focus:\n      // onFocus={ this.expandOnFocus }\n      // onClick={ this.onClick }\n      // WAI-ARIA 1.0 impelmentation info (accessibility):\n      // https://www.w3.org/TR/wai-aria-practices/#combobox\n      // https://www.levelaccess.com/differences-aria-1-0-1-1-changes-rolecombobox/\n\n      return _react2.default.createElement(_TextInputInput2.default, {\n        id: id ? id + '__input' : undefined,\n        inputRef: this.storeInput,\n        value: inputValue,\n        label: label,\n        placeholder: placeholder,\n        onChange: this.onInputValueChange,\n        onKeyDown: this.onKeyDown,\n        onBlur: this.onBlur,\n        role: 'combobox',\n        'aria-autocomplete': 'list',\n        'aria-expanded': isExpanded ? true : false,\n        'aria-haspopup': true,\n        'aria-owns': id && isExpanded ? id + '__list' : undefined,\n        'aria-activedescendant': id && focusedOptionIndex !== undefined ? id + '__list-item-' + focusedOptionIndex : undefined,\n        required: required,\n        tabIndex: tabIndex,\n        disabled: isFetchingInitiallySelectedOption || disabled,\n        indicateInvalid: indicateInvalid || matches === false,\n        error: error || (matches === false ? 'no-match' : undefined),\n        className: (0, _classnames2.default)('rrui__autocomplete__input', inputClassName)\n      });\n    }\n  }, {\n    key: 'getOptionsForRendering',\n    value: function getOptionsForRendering() {\n      var maxOptions = this.props.maxOptions;\n      var options = this.state.options;\n\n      if (maxOptions > 0 && options.length > maxOptions) {\n        return options.slice(0, maxOptions);\n      }\n\n      return options;\n    }\n  }, {\n    key: 'throttleFetchOptionsCall',\n    value: function throttleFetchOptionsCall(resolve) {\n      var _this3 = this;\n\n      var _props4 = this.props,\n          throttle = _props4.throttle,\n          minCharactersToStartThrottling = _props4.minCharactersToStartThrottling;\n      var inputValue = this.state.inputValue;\n      var wait = throttle - (Date.now() - this.latestFetchOptionsCallTimestamp);\n\n      if (inputValue.length >= minCharactersToStartThrottling && wait > 0) {\n        if (!this.nextFetchOptionsCallTimeout) {\n          this.nextFetchOptionsCallTimeout = setTimeout(function () {\n            _this3.nextFetchOptionsCallTimeout = undefined;\n\n            _this3.latestFetchOptionsCall();\n          }, wait);\n        }\n\n        this.latestFetchOptionsCall = function () {\n          return _this3.refreshOptions().then(resolve);\n        };\n\n        return true;\n      }\n    }\n  }, {\n    key: 'receiveNewOptions',\n    value: function receiveNewOptions(options, counter, callback) {\n      var _props5 = this.props,\n          getOptions = _props5.getOptions,\n          highlightFirstOption = _props5.highlightFirstOption;\n      var _state3 = this.state,\n          isExpanded = _state3.isExpanded,\n          matchesCounter = _state3.matchesCounter,\n          optionsCounter = _state3.optionsCounter,\n          fetchingOptionsCounter = _state3.fetchingOptionsCounter;\n      var newState = {};\n\n      if (getOptions) {\n        // Can only override \"older\" matching state.\n        if (isCounterAfter(counter, matchesCounter)) {\n          newState.matches = options.length > 0;\n          newState.matchesCounter = counter;\n        } // Update options.\n        // Can only override \"older\" options.\n        // (not \"newer\" ones)\n\n\n        if (isCounterAfter(counter, optionsCounter)) {\n          // Autocomplete should always display some options.\n          if (options.length > 0) {\n            newState.options = options;\n            newState.optionsCounter = counter;\n          }\n        }\n\n        if (counter === fetchingOptionsCounter) {\n          newState.isFetchingOptions = false;\n          newState.fetchingOptionsCounter = undefined;\n        }\n      } else {\n        newState.matches = options.length > 0; // Autocomplete should always display some options.\n\n        if (options.length > 0) {\n          newState.options = options;\n        }\n      }\n\n      if (newState.matches === false && !highlightFirstOption) {\n        if (isExpanded) {\n          this.list.clearFocus();\n        }\n      }\n\n      this.setState(newState, callback);\n    }\n  }], [{\n    key: 'getDerivedStateFromProps',\n    // Handles changing `value` externally for an `<Autocomplete/>`.\n    value: function getDerivedStateFromProps(_ref3, state) {\n      var value = _ref3.value,\n          options = _ref3.options;\n      var newState = {\n        // `prevProps`.\n        props: {\n          value: value // Changing `value` externally for an `<Autocomplete/>`\n          // with `async getOptions()` is not supported.\n\n        }\n      };\n\n      if (Array.isArray(options)) {\n        // `<Autocomplete/>`'s selected option label\n        // is stored in a special `selectedOption.label` variable in `state`.\n        if (value !== state.props.value) {\n          newState.selectedOption = options.filter(function (_) {\n            return _.value === value;\n          })[0];\n          newState.inputValue = newState.selectedOption ? newState.selectedOption.label : '';\n        }\n      }\n\n      return newState;\n    }\n  }]);\n\n  return Autocomplete;\n}(PureComponent), _class2.propTypes = {\n  // A list of selectable options\n  options: _propTypes2.default.arrayOf(_propTypes2.default.shape({\n    // Option value (may be `undefined`)\n    value: _propTypes2.default.any,\n    // Option label (may be `undefined`)\n    label: _propTypes2.default.string,\n    // Option icon\n    icon: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.func]),\n    // Render custom content (a React component).\n    // Receives `{ value, label }` properties.\n    content: _propTypes2.default.func\n  })).isRequired,\n  // An alternative way of getting `options`.\n  // If it's an `autocomplete` then this function\n  // receives the `query : string` argument.\n  // Is only for `autocomplete` mode.\n  // Must return a `Promise`.\n  getOptions: _propTypes2.default.func,\n  // Can be supplied when supplying `options` prop.\n  // By default filters by substring inclusion (case-insensitive).\n  filterOptions: _propTypes2.default.func.isRequired,\n  // The maximum number of options to be rendered\n  // in the options list when it's expanded.\n  // `0` means \"unlimited\".\n  maxOptions: _propTypes2.default.number,\n  // Throttle `async getOptions()` invocations.\n  throttle: _propTypes2.default.number.isRequired,\n  // Throttle `async getOptions()` invocations.\n  minCharactersToStartThrottling: _propTypes2.default.number.isRequired,\n  // HTML form input `name` attribute\n  name: _propTypes2.default.string,\n  // Label which is placed above the select\n  label: _propTypes2.default.string,\n  // Placeholder (like \"Choose\")\n  placeholder: _propTypes2.default.string,\n  // Show icon only for selected item,\n  // and only if `icon` is `true`.\n  saveOnIcons: _propTypes2.default.bool,\n  // Disables this control\n  disabled: _propTypes2.default.bool,\n  // Set to `true` to mark the field as required\n  required: _propTypes2.default.bool.isRequired,\n  // Selected option value\n  value: _propTypes2.default.any,\n  // Is called when an option is selected\n  onChange: _propTypes2.default.func,\n  // Is called when the select is blurred.\n  // This `onBlur` interceptor is a workaround for `redux-form`,\n  // so that it gets the parsed `value` in its `onBlur` handler,\n  // not the formatted text.\n  onBlur: _propTypes2.default.func,\n  // If `scroll` is `false`, then options list\n  // is not limited in height.\n  // Is `true` by default (scrollable).\n  scroll: _propTypes2.default.bool.isRequired,\n  // Component CSS class\n  className: _propTypes2.default.string,\n  // Autocomplete `<input/>` CSS class\n  inputClassName: _propTypes2.default.string,\n  // CSS style object\n  style: _propTypes2.default.object,\n  // If this flag is set to `true`,\n  // and `icon` is specified for a selected option,\n  // then the selected option will be displayed\n  // as icon only, without the label.\n  icon: _propTypes2.default.bool,\n  // If this flag is set to `true`,\n  // then it makes `<Autocomplete/>` not stretch itself\n  // to 100% width by making it `inline-block`.\n  // Is set to `true` when `icon` is `true`\n  // because it makes sense.\n  compact: _propTypes2.default.bool,\n  // HTML `tabindex` attribute\n  tabIndex: _propTypes2.default.number,\n  // If set to `true`, autocomple will show all\n  // matching options instead of just `maxItems`.\n  showAllMatchingOptions: _propTypes2.default.bool,\n  // `<Autocomplete/>` loads `async getOptions()` after it has been mounted.\n  // Until then `<Autocomplete/>` doesn't display any selected option.\n  // One may supply an already pre-loaded currently selected option\n  // to display the currently selected option sooner (e.g. Server-Side Rendering).\n  selectedOption: _propTypes2.default.object,\n  // WAI-ARIA requires any option be focused only on-demand\n  // when the user explicitly presses the Down arrow key.\n  // https://www.w3.org/TR/wai-aria-practices/examples/combobox/aria1.0pattern/combobox-autocomplete-list.html\n  // Still, it's not be the best user experience for non-disabled users:\n  // it would be more convenient for them if the first option was automatically focused.\n  // Hence this property.\n  // (is `false` by default for WAI-ARIA compliancy)\n  highlightFirstOption: _propTypes2.default.bool.isRequired\n}, _class2.defaultProps = {\n  // Set to `true` to mark the field as required\n  required: false,\n  // Show `error` (if passed).\n  indicateInvalid: true,\n  // Set to `true` to display the loading indicator\n  loading: false,\n  // Will show scrollbar on overflow.\n  scroll: true,\n  alignment: 'left',\n  // `async getOptions()` throttle period.\n  throttle: 200,\n  // `async getOptions()` throttle threshold (in characters).\n  minCharactersToStartThrottling: 4,\n  // Filters options by substring inclusion (case-insensitive).\n  filterOptions: filterOptions,\n  // The maximum number of options to be rendered\n  // in the options list when it's expanded.\n  // The rationale is that otherwise the UI could\n  // stagger when initially expanding a huge list.\n  // `0` means \"unlimited\".\n  maxOptions: 500,\n  // UX for non-disabled users is better this way.\n  // Disabled users still can use this component.\n  highlightFirstOption: true\n}, _temp2)) || _class; // There can be an `undefined` value,\n// so just `{ value }` won't do here.\n\n\nexports.default = Autocomplete;\n\nfunction getOptionKey(value) {\n  return isEmptyValue(value) ? '@@rrui/empty' : value;\n}\n\nfunction isEmptyValue(value) {\n  return value === null || value === undefined;\n} // Filters options by substring inclusion (case-insensitive).\n\n\nfunction filterOptions(options, value) {\n  // If the input value is `undefined` or empty.\n  if (!value) {\n    return options;\n  }\n\n  value = value.toLowerCase();\n  return options.filter(function (_ref4) {\n    var label = _ref4.label;\n    return label.toLowerCase().indexOf(value) >= 0;\n  });\n}\n\nvar Counter = function () {\n  function Counter() {\n    _classCallCheck(this, Counter);\n\n    this.counter = 0;\n  }\n\n  _createClass(Counter, [{\n    key: 'getNextCounter',\n    value: function getNextCounter() {\n      if (this.counter < MAX_SAFE_INTEGER) {\n        this.counter++;\n      } else {\n        this.counter = 1;\n      }\n\n      return this.counter;\n    }\n  }]);\n\n  return Counter;\n}(); // `MAX_SAFE_INTEGER` is not supported by older browsers\n\n\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1; // Can only override \"older\" options.\n// (not \"newer\" ones)\n\nfunction isCounterAfter(counter, currentStateCounter) {\n  var diff = counter - currentStateCounter; // If the new options are \"newer\" than the current ones,\n  // then they can override them.\n  // (also accounts for counter overflow)\n\n  return diff > 0 || diff < 0 && Math.abs(diff) > MAX_SAFE_INTEGER / 2;\n}\n\nfunction generateRandomString() {\n  return Math.random().toString().replace(/\\D/g, '');\n}","map":null,"metadata":{},"sourceType":"script"}