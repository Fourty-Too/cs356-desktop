{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _class, _temp2;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _classnames = require('classnames');\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nvar _throttle = require('lodash/throttle');\n\nvar _throttle2 = _interopRequireDefault(_throttle);\n\nvar _reactCreateRef = require('react-create-ref');\n\nvar _reactCreateRef2 = _interopRequireDefault(_reactCreateRef);\n\nvar _grid = require('./utility/grid');\n\nvar _dom = require('./utility/dom');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // `PureComponent` is only available in React >= 15.3.0.\n\n\nvar PureComponent = _react2.default.PureComponent || _react2.default.Component;\nvar TextInput = (_temp2 = _class = function (_PureComponent) {\n  _inherits(TextInput, _PureComponent);\n\n  function TextInput() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, TextInput);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = TextInput.__proto__ || Object.getPrototypeOf(TextInput)).call.apply(_ref, [this].concat(args))), _this), _this.initAutoresizeAttempts = 0, _this.currentHeight = 0, _this.hiddenTextArea = (0, _reactCreateRef2.default)(), _this.initAutoresize = function () {\n      if (!_this._isMounted) {\n        return;\n      }\n\n      _this.initAutoresizeAttempts++;\n\n      _this.getMeasurements();\n\n      if (_this.haveStylesLoaded()) {\n        _this.autoresize();\n      } // Even if padding on <textarea/> has been set\n      // it's still possible that `font-size` hasn't been set yet.\n      // Or it could be another padding in a subsequent stylesheet.\n      // So keep re-initializing <textarea/>, say, for a second.\n\n\n      if (_this.initAutoresizeAttempts <= 5) {\n        setTimeout(_this.initAutoresize, 200);\n      }\n    }, _this.autoresize = function (event) {\n      // const { rowsMax } = this.props\n      // Guarding for **broken** shallow rendering method that call componentDidMount\n      // but doesn't handle refs correctly.\n      // To remove once the shallow rendering has been fixed.\n      if (!_this.hiddenTextArea.current) {\n        return;\n      } // const lineHeight = this.hiddenTextAreaSingleLine.current.scrollHeight - this.verticalPadding\n\n\n      var height = _this.hiddenTextArea.current.scrollHeight; // Guarding for jsdom, where scrollHeight isn't present.\n      // See https://github.com/tmpvar/jsdom/issues/1013\n\n      if (height === undefined) {\n        return;\n      } // It would have to first subtract `paddingTop` and `paddingBottom`,\n      // then it would calculate `rowsMax * lineHeight` and\n      // then it would re-add `paddingTop` and `paddingBottom`.\n      // height = Math.min(rowsMax * lineHeight + this.verticalPadding, height)\n      // `.scrollHeight` doesn't include borders.\n      // `.style.height` does include borders.\n\n\n      height += _this.bordersHeight; // if (height <= this.minHeight) {\n      // \theight = this.minHeight\n      // }\n      // For some weird reason Chrome on Windows 10\n      // requires an extra pixel been added\n      // to avoid showing vertical scrollbar.\n      // (Oct 24th, 2018)\n      // else {\n\n      height += 1; // }\n      // \"Need a large enough different to update the height.\n      //  This prevents infinite rendering loop.\"\n      // It's unclear what loop they're talking about.\n\n      if (Math.abs(_this.currentHeight - height) > 1) {\n        _this.currentHeight = height; // `.style.height` includes borders.\n\n        _this.input.style.height = height + 'px';\n      }\n    }, _this.onWindowResize = (0, _throttle2.default)(function (event) {\n      return _this.autoresize();\n    }, 100), _this.onChange = function (event) {\n      // Extract `value` from the argument\n      // of this `onChange` listener\n      // (for convenience)\n      var value = event;\n\n      if (event.target !== undefined) {\n        value = event.target.value;\n      } // Call the parent `onChange` handler\n      // with the `value` as an argument\n      // (for convenience)\n\n\n      var onChange = _this.props.onChange; // Call `onChange` only if `value` did actually change\n\n      if (value !== _this.props.value) {\n        onChange(value);\n      }\n    }, _this.onKeyDown = function (event) {\n      var onKeyDown = _this.props.onKeyDown;\n\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      if (event.defaultPrevented) {\n        return;\n      }\n\n      if ((0, _dom.submitFormOnCtrlEnter)(event, _this.input)) {\n        return;\n      }\n    }, _this.storeInputNode = function (node) {\n      var inputRef = _this.props.inputRef;\n\n      if (inputRef) {\n        inputRef(node);\n      }\n\n      _this.input = node;\n    }, _this.focus = function () {\n      return _this.input.focus();\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(TextInput, [{\n    key: 'componentDidMount',\n    // hiddenTextAreaSingleLine = createRef()\n    // Client side rendering, javascript is enabled\n    value: function componentDidMount() {\n      var _props = this.props,\n          multiline = _props.multiline,\n          autoresize = _props.autoresize,\n          value = _props.value;\n      this._isMounted = true; // Doing `this.measure()` here now\n      // because `<textarea/>` should autoresize\n      // in case its `value` is set up front.\n      // // Not doing `this.measure()` here because\n      // // that resulted in weird `<textarea/>` height mismatch.\n      // // Measuring the height of `<textarea/>` during\n      // // the first `this.measurements()` call instead.\n\n      if (multiline && autoresize) {\n        this.initAutoresize();\n      }\n\n      if (multiline && autoresize) {\n        window.addEventListener('resize', this.onWindowResize);\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      var _props2 = this.props,\n          multiline = _props2.multiline,\n          autoresize = _props2.autoresize;\n      this._isMounted = false;\n\n      if (multiline && autoresize) {\n        window.removeEventListener('resize', this.onWindowResize);\n      }\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      var autoresize = this.props.autoresize;\n\n      if (autoresize) {\n        this.autoresize();\n      }\n    } // Even if padding on <textarea/> has been set\n    // it's still possible that `font-size` hasn't been set yet.\n    // (it happened in a project)\n    // So this function doesn't guarantee anything.\n\n  }, {\n    key: 'haveStylesLoaded',\n    value: function haveStylesLoaded() {\n      // The default <textarea/> top/bottom padding in Chrome on Windows is 2px.\n      return this.verticalPadding > 2 * 2;\n    } // `height` works incorrectly in some weird cases.\n    // For example, when `<textarea/>` is hidden when mounted\n    // or when there's no stylesheet loaded yet.\n    // For example, when stylesheets are included \"dynamically\"\n    // like Webpack's `style-loader` does (is used in development mode,\n    // or when using \"code splitting\" when \"chunks\" are `import()`ed dynamically).\n    //\n    // https://stackoverflow.com/questions/39400038/how-to-ensure-that-hot-css-loads-before-js-in-webpack-dev-server\n    // https://github.com/webpack-contrib/style-loader/issues/269\n    //\n    // An alternative solution would be:\n    //\n    // this.input.minHeight = 0\n    // this.input.minHeight = this.input.scrollHeight + this.bordersHeight\n    //\n    // or:\n    //\n    // this.input.minHeight = this.hiddenTextArea.current.scrollHeight + this.bordersHeight\n    //\n    // which wouldn't ever undersize the <textarea/>\n    // but it would oversize it due to the incorrect\n    // <textarea/> width before styles are loaded.\n    //\n\n  }, {\n    key: 'getMeasurements',\n    value: function getMeasurements() {\n      var style = getComputedStyle(this.input); // // Measurements can be in `em`s/`rem`s/`pt`s which can give fractional pixel sizes.\n      // // `style.height` includes borders.\n      // this.currentHeight = Math.ceil(parseFloat(style.height))\n      // this.minHeight = this.currentHeight\n      // Get vertical padding.\n      // Measurements can be in `em`s/`rem`s/`pt`s which can give fractional pixel sizes.\n\n      this.verticalPadding = Math.ceil(parseFloat(style.paddingTop)) + Math.ceil(parseFloat(style.paddingBottom)); // Top and bottom borders are extra height,\n      // because `.scrollHeight` doesn't include borders.\n      // Measurements can be in `em`s/`rem`s/`pt`s which can give fractional pixel sizes.\n\n      this.bordersHeight = Math.ceil(parseFloat(style.borderTopWidth)) + Math.ceil(parseFloat(style.borderBottomWidth));\n    } // Copy-pasted from Material UI on Oct 24th, 2018.\n    // https://github.com/mui-org/material-ui/blob/master/packages/material-ui/src/InputBase/Textarea.js\n    //\n    // The underlying `input` component\n    // can pass both `event`s and `value`s\n    // to this parent `onChange` listener.\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props3 = this.props,\n          id = _props3.id,\n          value = _props3.value,\n          multiline = _props3.multiline,\n          inputComponent = _props3.inputComponent,\n          focus = _props3.focus,\n          onChange = _props3.onChange,\n          disabled = _props3.disabled,\n          label = _props3.label,\n          placeholder = _props3.placeholder,\n          type = _props3.type,\n          autoresize = _props3.autoresize,\n          indicateInvalid = _props3.indicateInvalid,\n          error = _props3.error,\n          className = _props3.className,\n          inputRef = _props3.inputRef,\n          containerRef = _props3.containerRef,\n          floatingLabel = _props3.floatingLabel,\n          required = _props3.required,\n          children = _props3.children,\n          rest = _objectWithoutProperties(_props3, ['id', 'value', 'multiline', 'inputComponent', 'focus', 'onChange', 'disabled', 'label', 'placeholder', 'type', 'autoresize', 'indicateInvalid', 'error', 'className', 'inputRef', 'containerRef', 'floatingLabel', 'required', 'children']);\n\n      var inputStyle = this.props.inputStyle;\n\n      if (multiline && autoresize) {\n        inputStyle = _extends({\n          resize: 'none'\n        }, inputStyle);\n      }\n\n      var properties = _extends({}, rest, {\n        id: id,\n        ref: this.storeInputNode,\n        value: isEmptyValue(value) ? '' : value,\n        disabled: disabled,\n        'aria-label': rest['aria-label'] || (id && label ? undefined : label),\n        'aria-required': rest['aria-required'] || (required ? true : undefined),\n        'aria-invalid': rest['aria-invalid'] || (error && indicateInvalid ? true : undefined),\n        placeholder: placeholder,\n        onChange: this.onChange,\n        onKeyDown: this.onKeyDown,\n        className: (0, _classnames2.default)( // `<TextInput/>` has `border-color` to indicate its `:focus` state.\n        // Therefore the `outline` can be safely removed.\n        'rrui__outline', 'rrui__input-element', 'rrui__input-field', {\n          // CSS selector performance optimization\n          'rrui__input-field--invalid': indicateInvalid && error,\n          'rrui__input-field--disabled': disabled,\n          'rrui__input-field--multiline': multiline\n        }, className),\n        style: inputStyle,\n        autoFocus: focus // In case of `multiline` set to `true`\n        // this is gonna be a `<textarea/>`\n\n      });\n\n      if (multiline) {\n        if (autoresize) {\n          return [// <textarea\n          // \tkey=\"textarea-measurement-single-line\"\n          // \tref={this.hiddenTextAreaSingleLine}\n          // \trows=\"1\"\n          // \treadOnly\n          // \taria-hidden=\"true\"\n          // \tvalue=\"\"\n          // \ttabIndex={-1}\n          // \tclassName={properties.className}\n          // \tstyle={this.props.inputStyle ? { ...inputStyle, ...HIDDEN_TEXTAREA_STYLE } : HIDDEN_TEXTAREA_STYLE}/>,\n          _react2.default.createElement('textarea', {\n            key: 'textarea-measurement',\n            ref: this.hiddenTextArea,\n            readOnly: true,\n            'aria-hidden': true,\n            value: properties.value,\n            rows: properties.rows,\n            tabIndex: -1,\n            className: properties.className,\n            style: this.props.inputStyle ? _extends({}, inputStyle, HIDDEN_TEXTAREA_STYLE) : HIDDEN_TEXTAREA_STYLE\n          }), _react2.default.createElement('textarea', _extends({\n            key: 'textarea'\n          }, properties))];\n        }\n\n        return _react2.default.createElement('textarea', _extends({\n          key: 'textarea'\n        }, properties));\n      } // Add `<input/>` `type` property.\n\n\n      if (inputComponent === 'input') {\n        properties.type = type || 'text';\n      }\n\n      return _react2.default.createElement(inputComponent, properties);\n    }\n  }]);\n\n  return TextInput;\n}(PureComponent), _class.propTypes = {\n  // (optional) HTML `id` attribute.\n  id: _propTypes2.default.string,\n  // `<input type/>` attribute.\n  type: _propTypes2.default.string,\n  // Whether `<textarea/>` should autoresize itself\n  // (is `true` by default)\n  autoresize: _propTypes2.default.bool.isRequired,\n  // In order for this to work properly\n  // `<textarea/>` vertical padding should be `0`\n  // and instead the padding should be defined on `<textarea/>` parent `<div/>`\n  // like it's done in Material UI.\n  // Otherwise it won't look pretty and the line of text near the top border\n  // will be partially visible resulting in weird UX.\n  // If `<textarea/>` vertical padding was `0`\n  // the line of text near the top border wouldn't be visible.\n  // // The maximum number of rows <textarea/> grows up to.\n  // rowsMax          : PropTypes.number.isRequired,\n  // Set to `false` to prevent the `<label/>` from floating\n  floatingLabel: _propTypes2.default.bool.isRequired,\n  // A custom input component.\n  // (is `<input/>` by default)\n  inputComponent: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.string]).isRequired\n}, _class.defaultProps = {\n  // `<textarea/>` should autoresize itself\n  autoresize: true,\n  // Set to `false` to prevent the `<label/>` from floating\n  floatingLabel: true,\n  // A custom input component.\n  // (is `<input/>` by default)\n  inputComponent: 'input' // // The maximum number of rows <textarea/> grows up to.\n  // rowsMax : 12\n\n}, _temp2); // https://github.com/mui-org/material-ui/blob/master/packages/material-ui/src/InputBase/Textarea.js\n\nexports.default = TextInput;\nvar HIDDEN_TEXTAREA_STYLE = {\n  // Overflow also needed to here to remove the extra row\n  // added to `<textarea/>`s in Firefox.\n  overflow: 'hidden',\n  // Visibility needed to hide the extra `<textarea/>` on iPads.\n  visibility: 'hidden',\n  position: 'absolute',\n  height: 'auto',\n  // Don't know why is it here.\n  whiteSpace: 'pre-wrap'\n};\n\nfunction isEmptyValue(value) {\n  return value === '' || value === undefined || value === null;\n}","map":null,"metadata":{},"sourceType":"script"}