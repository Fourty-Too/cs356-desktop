{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseDate = parseDate;\nexports.formatDate = formatDate;\nexports.parseDateCustom = parseDateCustom;\nexports.correspondsToTemplate = correspondsToTemplate;\nexports.formatDateCustom = formatDateCustom;\nexports.normalizeDate = normalizeDate;\nexports.trimInvalidPart = trimInvalidPart; // // Moment.js takes 161 KB of space (minified) which is too much\n// import moment from 'moment'\n// // `date-fns` would be a better alternative to moment\n// // but it doesn't support templated date parsing\n// // until version `2.0.0` of it is released.\n// // https://github.com/date-fns/date-fns/issues/347\n// import parse_date_date_fns from 'date-fns/parse'\n// import format_date_date_fns from 'date-fns/format'\n// Parses a text value into a `Date` provided a `format`.\n// The date returned is in the user's time zone and the time is `12:00`.\n\nfunction parseDate(text_value, format, noon, utc) {\n  if (!text_value) {\n    return;\n  } // Custom\n\n\n  return parseDateCustom(text_value, format, noon, utc); // // Using `date-fns`\n  // const date = parse_date_date_fns(text_value)\n  // if (isNaN(date.getTime()))\n  // {\n  // \treturn\n  // }\n  // return date\n  // // Using `Moment.js`\n  // const moment_day = moment(text_value, format, true)\n  // if (!moment_day.isValid())\n  // {\n  // \treturn\n  // }\n  // return moment_day.toDate()\n} // (Moment.js)\n// Formats a `Date` into a text value provided a `format`\n\n\nfunction formatDate(date, format) {\n  // Custom\n  return formatDateCustom(date, format); // // Using `date-fns`\n  // return format_date_date_fns(date, format)\n  // // Using `Moment.js`\n  // return moment(date).format(format)\n} // Parses a text value into a `Date` provided a `format`.\n// The date returned is in the user's time zone and the time is `00:00`.\n// (only `DD`, `MM`, `YY` and `YYYY` literals are supported).\n\n\nfunction parseDateCustom(string, format, noon, utc) {\n  if (!string) {\n    return;\n  }\n\n  var year = extract(string, format, 'YYYY');\n\n  if (year === undefined) {\n    year = extract(string, format, 'YY');\n\n    if (year !== undefined) {\n      // Current year in the user's time zone.\n      var current_year_and_century = new Date().getFullYear();\n      var current_year = current_year_and_century % 100;\n      var century = (current_year_and_century - current_year) / 100;\n\n      if (year >= current_year) {\n        if (year - current_year > 100 * 1 / 5) {\n          century--;\n        }\n      } else {\n        if (current_year - year > 100 * 4 / 5) {\n          century++;\n        }\n      }\n\n      year += century * 100;\n    }\n  }\n\n  var month = extract(string, format, 'MM');\n  var day = extract(string, format, 'DD');\n\n  if (year === undefined || month === undefined || day === undefined) {\n    return;\n  } // The date created is in the user's time zone and the time is `00:00`.\n\n\n  var date = new Date(year, month - 1, day, noon ? 12 : 0);\n\n  if (utc) {\n    // Converts timezone to UTC while preserving the same time\n    date = convertToUtcTimezone(date);\n  } // If `new Date()` returns \"Invalid Date\"\n  // (sometimes it does)\n\n\n  if (isNaN(date.getTime())) {\n    return;\n  }\n\n  return date;\n}\n\nfunction extract(string, template, piece) {\n  var starts_at = template.indexOf(piece);\n\n  if (starts_at < 0) {\n    return;\n  } // Check overall sanity\n\n\n  if (!correspondsToTemplate(string, template)) {\n    return;\n  }\n\n  var number = parseInt(string.slice(starts_at, starts_at + piece.length));\n\n  if (!isNaN(number)) {\n    return number;\n  }\n}\n\nfunction correspondsToTemplate(string, template) {\n  if (string.length !== template.length) {\n    return false;\n  }\n\n  var i = 0;\n\n  while (i < string.length) {\n    var is_a_digit = string[i] >= '0' && string[i] <= '9';\n\n    if (!is_a_digit) {\n      if (string[i] !== template[i]) {\n        return false;\n      }\n    } else {\n      if (template[i] !== 'D' && template[i] !== 'M' && template[i] !== 'Y') {\n        return false;\n      }\n    }\n\n    i++;\n  }\n\n  return true;\n}\n\nfunction formatDateCustom(date, format) {\n  // Someone may accidentally pass a timestamp, or a string.\n  // Or `date` could be `undefined`.\n  if (!(date instanceof Date)) {\n    return '';\n  } // Check if `date` is \"Invalid Date\".\n\n\n  if (isNaN(date.getTime())) {\n    return '';\n  }\n\n  var day = date.getDate();\n  var month = date.getMonth() + 1;\n  var year = date.getFullYear();\n  var text = format.replace('DD', padWithZeroes(String(day), 2)).replace('MM', padWithZeroes(String(month), 2));\n\n  if (text.indexOf('YYYY') >= 0) {\n    return text.replace('YYYY', padWithZeroes(String(year), 4));\n  }\n\n  if (text.indexOf('YY') >= 0) {\n    return text.replace('YY', padWithZeroes(String(year % 100), 2));\n  }\n}\n\nfunction padWithZeroes(string, target_length) {\n  while (string.length < target_length) {\n    string = '0' + string;\n  }\n\n  return string;\n} // // Intl date formatting\n//\n// const dateFormatters = {}\n//\n// function format_dateIntl(date, locale) {\n//   if (typeof Intl === 'undefined') {\n//     return date.toISOString()\n//   }\n//\n//   const key = typeof locale === 'string' ? locale : locale.join(',')\n//\n//   if (!dateFormatters[key]) {\n//     dateFormatters[key] = new Intl.DateTimeFormat(locale, {\n//       day: '2-digit',\n//       month: '2-digit',\n//       year: 'numeric'\n//     })\n//   }\n//\n//   return dateFormatters[key]\n// }\n// Converts `null` to `undefined`\n// (specially for `knex.js`)\n\n\nfunction normalizeDate(value) {\n  if (value === null) {\n    return;\n  } // Check if `value` is \"Invalid Date\".\n\n\n  if (value instanceof Date && isNaN(value.getTime())) {\n    return;\n  }\n\n  return value;\n}\n\nfunction trimInvalidPart(value, format) {\n  var i = 0;\n\n  while (i < value.length && i < format.length) {\n    if (format[i] === 'D' || format[i] === 'M' || format[i] === 'Y') {\n      if (!(value[i] >= '0' && value[i] <= '9')) {\n        break;\n      }\n    } else if (format[i] !== value[i]) {\n      break;\n    }\n\n    i++;\n  }\n\n  return value.slice(0, i);\n} // Converts timezone to UTC while preserving the same time\n\n\nfunction convertToUtcTimezone(date) {\n  // Doesn't account for leap seconds but I guess that's ok\n  // given that javascript's own `Date()` does not either.\n  // https://www.timeanddate.com/time/leap-seconds-background.html\n  //\n  // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset\n  //\n  return new Date(date.getTime() - date.getTimezoneOffset() * 60 * 1000);\n}","map":null,"metadata":{},"sourceType":"script"}